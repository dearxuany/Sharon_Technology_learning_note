# Linux IO模型：同步、异步、阻塞、非阻塞
## 关于IO模型
### 定义
IO指的是Input/Output，即输入、输出。</br>
通常，程序完成IO操作会有Input和Output两个数据流，当然也有只用一个的情况。</br>
如从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</br>
</br>
IO编程中，Stream（流）是一个很重要的概念。</br>
Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。</br>

### 常见的IO模型
出现IO模型的原因是通常CPU和内存的速度远远高于外设的速率，进行数据处理与传输时需要协调配合每种设备对于数据的传输处理速率，同时还要提高每种设备的利用率，让系统总体速率得到提高。不同IO模型之间的差别本质上体现的是CPU的不同参与方式。</br>
</br>
术语上面讲，常见的几个与IO模型相关的术语有：</br>
同步synchronous IO、异步asynchronous IO、阻塞blocking IO、非阻塞non-blocking IO</br>
还有其他的一些IO模型：</br>
多路复用multiplexing IO、信号驱动式signal-driven IO</br>
</br>
IT细分下的不同领域貌似对这几个术语的定义有些不同，有些人会把同步和阻塞划等号、异步和非阻塞划等号，但是又有人认为它们不一样，所以这些词的具体定义还是需要根据问题的背景来做针对性的解释。用这些词的时候需要相互确定一下交流双方讨论的是同一个东西。
（我大学的时候学的信息工程，听得比较多的术语是同步和异步，毕业后和其他相关专业朋友交流听到阻塞和非阻塞的频率就变多了。其中，在python相关的编程情景下，很多时候就直接把同步和阻塞等同起来。多路复用IO、信号驱动式 IO在网络模型物理层和数据链路层相关的服务领域用得就非常多。）</br>
</br>
一般概念分析：

#### 同步与异步
同步与异步主要是从消息通知机制角度来说的，关键在于调用者是否有等待这个行为出现。

* 同步synchronous IO</br>
同步IO：</br>
顾名思义，就是CPU和其他设备同时只做同行一件事。CPU将数据交给其他设备后，什么都不干，等着其他设备将数据处理完毕后再接收处理好的数据，之后CPU再重新开始运行接下来需要进行的程序。</br>
同步IO较为可靠，因为参与数据传输的两个设备都在做同一件事，会保证这件事完整地被做完，并且双方都可以确认这个任务是完整被完成的（有点像RDBMS里的原子性？）。</br>
机制上，当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行。比如，网络编程socket最简单的服务器编程上，服务端会一直listen监听等待客户端的connect连接，连接完成服务端给客户端传信息，服务端传完信息给客户端后等待客户端处理这些数据，在此期间服务端什么都不做只等待客户端回传信息，这样服务端的效率就变低了。</br>
</br>

* 异步asynchronous IO</br>
异步IO：</br>
即CPU和其他设备不会同时集中精力来处理同一件事。CPU将数据交给其他外设后，就去做其他事情了，等外设处理好了那些数据后，CPU再回来接收这些数据。这样CPU的利用率就提高了，而且多个事情的处理总体效率也提高了。</br>
异步IO是不可靠的，参与数据传输的设备各自只确保自己负责的部分，并不关心这个任务整体到底完成没有，自己的任务做完了，设备就当这任务成功完成了。</br>
机制上，异步过程中调用者发出调用后不等待被调用对象的返回信息，而是让被调用对象在完成任务后通过状态、通知或回调来通知调用者回来完成它在这个任务中该做的事。通知调用者的方式由被调用对象的设置确定，编程上与此相关的术语则是“回调机制”，执行此操作的函数被称作“回调函数callback”，调用者告诉被调用对象以什么方式callback的函数称作“登记回调函数”，调用者回来继续干后续的任务称作“响应回调事件”。</br>

#### 阻塞和非阻塞
阻塞和非阻塞，主要与程序（线程）等待消息通知时的状态有关，重点在于线程所处的状态。</br>
线程可以被看做一个轻量级的进程，一个进程可以拥有多个线程。进程Process是系统资源分配的基本单位，每个进程拥有独立的资源，线程可以调用进程所有的资源，而同一进程里的每个线程共享这个进程的资源，所以各个线程存在竞争关系，线程之间相互制约，致使线程在运行中呈现出间断性。线程有就绪、阻塞和运行三种基本状态。单个程序可看作一个进程，单个程序中同时运行多个线程完成不同的工作，称为多线程。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</br>
</br>
举个例子，调用者给被调用对象传输完必要的数据后，调用者有两种选择：等待和不等待。</br>
在等待的过程中，可分为边等边干其他事以及完全单纯地在等待。因为这个过程中调用者确实是在等被调用对象的返回结果，所以这个过程肯定是“同步”的。
* 如果调用者在等待过程中还分心去干其他事，那么调用者处于“非阻塞”状态，进而这个过程称为“同步非阻塞”；</br>
* 如果调用者单纯地在等待，那么调用者处于“阻塞”的状态，进而这个过程被称为“同步阻塞”。</br>

如果调用者处于不等待的状态下，调用者完全不关心被调用对象什么时候干完活，那么可以确定这个过程是异步的，因为调用者可以去干其他事，但此时调用者也可以选干或者不干其他事。在保证效率的前提下肯定会选干其他事，这被称为“异步非阻塞”。</br>

#### 同步/异步和阻塞/非阻塞的关系
* 异步非阻塞</br>
效率是最高的，体现在调用者没等，被调用对象有机制提醒调用者活干完了；</br>
* 同步阻塞</br>
编程比较简单，体现在调用者等待，被调用对象没有提醒调用者活干完的机制，靠调用者盯进度；</br>
* 同步非阻塞</br>
因为调用者不断分心在两件事间跳来跳去，所以其实效率是不高的，体现在调用者边等边做自己的事，被调用对象没有提醒机制，也靠调用者盯进度；</br>
* 异步阻塞</br>
实际上调用者还是在等被调用者，因为尽管被调用对象有机制提醒调用者自己活干完了，调用者还是什么都不干，傻傻地在等待。</br>

总体上，实际遇到的是“异步非阻塞”和“同步阻塞”这两种情况比较多，但逻辑上同步/异步和阻塞/非阻塞是不一样的概念。</br>

