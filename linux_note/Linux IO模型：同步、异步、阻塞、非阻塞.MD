# Linux IO模型：同步、异步、阻塞、非阻塞
## 关于IO模型
### 定义
IO指的是Input/Output，即输入、输出。</br>
通常，程序完成IO操作会有Input和Output两个数据流，当然也有只用一个的情况。</br>
如从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</br>
</br>
IO编程中，Stream（流）是一个很重要的概念。</br>
Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。</br>

### 常见的IO模型
出现IO模型的原因是通常CPU和内存的速度远远高于外设的速率，进行数据处理与传输时需要协调配合每种设备对于数据的传输处理速率，同时还要提高每种设备的利用率，让系统总体速率得到提高。不同IO模型之间的差别本质上体现的是CPU的不同参与方式。</br>
</br>
术语上面讲，常见的几个与IO模型相关的术语有：</br>
同步synchronous IO、异步asynchronous IO、阻塞blocking IO、非阻塞non-blocking IO</br>
还有其他的一些IO模型：</br>
多路复用multiplexing IO、信号驱动式signal-driven IO</br>
</br>
IT细分下的不同领域貌似对这几个术语的定义有些不同，有些人会把同步和阻塞划等号、异步和非阻塞划等号，但是又有人认为它们不一样，所以这些词的具体定义还是需要根据问题的背景来做针对性的解释。用这些词的时候需要相互确定一下交流双方讨论的是同一个东西。
（我大学的时候学的信息工程，听得比较多的术语是同步和异步，毕业后和其他相关专业朋友交流听到阻塞和非阻塞的频率就变多了。其中，在python相关的编程情景下，很多时候就直接把同步和阻塞等同起来。多路复用IO、信号驱动式 IO在网络模型物理层和数据链路层相关的服务领域用得就非常多。）</br>
</br>
一般概念分析：

#### 同步与异步
同步与异步主要是从消息通知机制角度来说的，关键在于调用者是否有等待这个行为出现。

* 同步synchronous IO</br>
同步IO：</br>
顾名思义，就是CPU和其他设备同时只做同行一件事。CPU将数据交给其他设备后，什么都不干，等着其他设备将数据处理完毕后再接收处理好的数据，之后CPU再重新开始运行接下来需要进行的程序。</br>
同步IO较为可靠，因为参与数据传输的两个设备都在做同一件事，会保证这件事完整地被做完，并且双方都可以确认这个任务是完整被完成的（有点像RDBMS里的原子性？）。</br>
机制上，当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行。比如，网络编程socket最简单的服务器编程上，服务端会一直listen监听等待客户端的connect连接，连接完成服务端给客户端传信息，服务端传完信息给客户端后等待客户端处理这些数据，在此期间服务端什么都不做只等待客户端回传信息，这样服务端的效率就变低了。</br>
</br>

* 异步asynchronous IO</br>
异步IO：</br>
即CPU和其他设备不会同时集中精力来处理同一件事。CPU将数据交给其他外设后，就去做其他事情了，等外设处理好了那些数据后，CPU再回来接收这些数据。这样CPU的利用率就提高了，而且多个事情的处理总体效率也提高了。</br>
异步IO是不可靠的，参与数据传输的设备各自只确保自己负责的部分，并不关心这个任务整体到底完成没有，自己的任务做完了，设备就当这任务成功完成了。</br>
机制上，异步过程中调用者发出调用后不等待被调用对象的返回信息，而是让被调用对象在完成任务后通过状态、通知或回调来通知调用者回来完成它在这个任务中该做的事。通知调用者的方式由被调用对象的设置确定，编程上与此相关的术语则是“回调机制”，执行此操作的函数被称作“回调函数callback”，调用者告诉被调用对象以什么方式callback的函数称作“登记回调函数”，调用者回来继续干后续的任务称作“响应回调事件”。</br>
