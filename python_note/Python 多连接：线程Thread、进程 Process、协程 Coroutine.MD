# Python 多任务/多连接：</br>线程Thread、进程 Process、协程 Coroutine

多任务：对于本地计算机，让CPU同时处理多项工作</br>
多连接：对于网络，让服务器同时处理多个客户端连接请求</br>
</br>
实现多任务/多连接的常见方法：</br>
1.多进程forking（分叉）</br>
2. 多线程threading</br>
3. 异步I/O asynchronous I/O ：select和poll、epoll、Twisted框架（协程：单线程的异步编程、事件驱动模型）</br>
</br>
其中，win不支持分叉，而linux会把线程看作一种特殊的进程。</br>
多进程和多线程是在以并行的方式解决多连接/多任务问题，而异步是基于单线程单进程来讨论的。比如一个物理硬件的IO接口，并行接口和串行接口，对于单个接口，数据传输方式又有同步和异步之分，接口和数据传输的方式都会影响到物理硬件间数据传输的速率。</br>
</br>
Unix/linux下，通过多进程实现多任务可以用os模块中的fork()，要实现跨平台（如在win上）的多进程可用multiprocessing模块来模拟fork，进程间通信是通过Queue、Pipes等实现的。</br>
Windows下，多线程的效率比多进程要高，所以Win上实现多任务用多线程较多。但是，在Python中可以使用多线程，但因为一些问题不能有效利用多核CPU，例如编程比较复杂、要加锁但又要避免死锁的发生，所以其实并不适合用python来通过多线程实现多任务。
甚至有些时候，还采用多进程和多线程的混合模式。</br>
</br>
在线程Thread和进程 Process中，应当优选Process，因为Process更稳定，而且Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</br>
多任务环境中，通常是master-worker模式：</br>
master主进程/主线程负责分配任务，worker负责执行任务。</br>
多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。</br>
多线程模式通常比多进程快一点但不会快很多，但任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。</br>
</br>
多线程和多进程只是因为CPU在多任务情景下在任务间切换的速度非常快，所以在用户角度来看好像多个任务在同时进行而已。但无论是多进程还是多线程，任务一多，效率还是不高的。因为操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。当多任务的任务量达到一定程度，任务间切换消耗掉系统大部分的资源，便有可能让多进程或多线程系统瘫痪。</br>
</br>
对于单进程单线程来说，要实现多任务会采用异步的数据传输方式。现时比较新的异步I/O模型是“事件驱动模型”，让系统在在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。对于Python，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。Python基于“事件驱动模型”的网络框架有Twisted，可在基本类的基础定义专用类来定义更细致的事件，以应对服务器多连接的状况。</br>
